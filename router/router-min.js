let hooked=!1,methods={hashChangeListener:null,rootElement:null,title:e=>{if(hooked)throw new Error("Cannot send headers after they where already sent please refrain from using double res functions and call res.return() to resend to client");document.title=e,hooked=!0},setCookie:(e,t,n)=>{if(hooked)throw new Error("Cannot send headers after they where already sent please refrain from using double res functions and call res.return() to resend to client");let s=`${e}=${t};`;n&&(n.path&&(s+=`path=${n.path};`),n.domain&&(s+=`domain=${n.domain};`),n.maxAge&&(s+=`max-age=${n.maxAge};`),n.httpOnly&&(s+=`httpOnly=${n.httpOnly};`),n.secure&&(s+=`secure=${n.secure};`),n.sameSite&&(s+=`sameSite=${n.sameSite};`)),document.cookie=s},getCookie:e=>{const t=document.cookie.split(";");for(let n=0;n<t.length;n++){const s=t[n].trim(),o=s.split("=")[0];if(o===e){const e=s.split("=")[1];s.split(";").slice(1).map(e=>{const[t,n]=e.split("=").map(e=>e.trim());return{[t]:n}}).reduce((e,t)=>Object.assign(e,t),{});return{name:o,value:e}}}return null},saveState:()=>{if(hooked)throw new Error("State has already been saved cannot save again");const e=window.location.hash.substring(1);window.sessionStorage.getItem(e)?window.location.hash=window.sessionStorage.getItem(e):window.sessionStorage.setItem(e,e),hooked=!0},restoreState:()=>{if(hooked)throw new Error("State has already been restored cannot restore again");let e=window.location.hash.substring(1);window.sessionStorage.getItem(e)?window.location.hash=window.sessionStorage.getItem(e):window.location.hash=this.currentUrl,hooked=!0},send:e=>{if(hooked)throw new Error("Cannot send headers after they where already sent please refrain from using double res functions and call res.return() to resend to client");document.getElementById(methods.rootElement).innerHTML=e,hooked=!0},render:e=>{if(hooked)throw new Error("Cannot send headers after they where already sent please refrain from using double res functions and call res.return() to resend to client");renderTemplate(e),window.postMessage({render:e},"*"),hooked=!0},return:()=>{hooked&&(hooked=!1),methods.hashChangeListener&&(window.removeEventListener("hashchange",methods.hashChangeListener),methods.hashChangeListener=null)},sendStatus:(e,t)=>{if(hooked)throw new Error("Cannot send headers after they where already sent please refrain from using double res functions and call res.return() to resend to client");if("number"!=typeof t)throw new Error("Invalid status code");document.getElementById(methods.rootElement).innerHTML=JSON.stringify({msg:e,code:t}),hooked=!0},redirect:e=>{if(e=e.replace("#",""),hooked)throw new Error("Cannot send headers after they where already sent please refrain from using double res functions and call res.return() to resend to client");window.location.hash="#"+e,hooked=!0},sendFile:e=>{let t=window.config.Dox.root;if(hooked)throw new Error("Cannot send headers after they where already sent please refrain from using double res functions and call res.return() to resend to client");let n=new XMLHttpRequest;n.open("GET",e),n.responseType="blob",n.onload=function(){if(e.endsWith(".png"))document.querySelector(t).style="\n            position: fixed;\n           top: 0;\n          left: 0;\n         width: 100%;\n       height: 100%;\n      background-color: black;\n            \n            ",document.querySelector(t).innerHTML=` \n    <img src="${e}" style="resize: none; border: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);"/>`;else if(e.endsWith(".json"))fetch(e).then(e=>e.json()).then(e=>{const n=`<textarea style="width:100%;height:100%; resize:none; border:none;">${JSON.stringify(e)}</textarea>`;document.querySelector(t).innerHTML=n});else if(e.endsWith(".js"))fetch(e).then(e=>e.text()).then(e=>{const n=`<textarea style="width:100%;height:100%; resize:none; border:none;">${e}</textarea>`;document.querySelector(t).innerHTML=n});else if(e.endsWith(".css"))fetch(e).then(e=>e.text()).then(e=>{const n=`<textarea style="width:100%;height:100%; resize:none; border:none;">${e}</textarea>`;document.querySelector(t).innerHTML=n});else if(e.endsWith(".html"))fetch(e).then(e=>e.text()).then(e=>{const n=`<textarea style="width:100%;height:100%; resize:none; border:none;">${e}</textarea>`;document.querySelector(t).innerHTML=n});else if(e.endsWith(".img")||e.endsWith(".png")||e.endsWith(".jpg")||e.endsWith(".jpeg")||e.endsWith(".gif")||e.endsWith(".svg")||e.endsWith(".ico"))document.querySelector(t).innerHTML=`\n                <img src="${e}" \n                \n                style="width:100%;height:100%; resize:none; border:none; position:absolute; top:0; left:0;"\n                 \n                />\n                `;else if(e.endsWith(".pdf"))document.querySelector(t).innerHTML=`\n                <embed src="${e}" \n                \n                style="width:100%;height:100%; resize:none; border:none; position:absolute; top:0; left:0;"\n                 \n                />\n                `;else if(e.endsWith(".mp4")||e.endsWith(".webm")||e.endsWith(".ogg")){let n=document.createElement("video");n.src=e,n.controls=!0,document.querySelector(t).appendChild(n)}else{let n=document.createElement("audio");n.src=e,n.controls=!0,document.querySelector(t).appendChild(n)}let s=document.createElement("a");s.href=window.URL.createObjectURL(n.response),s.download=e,s.click()},n.send()}}
/**
 * @fileoverview Router class for handling routing throughout your app.
 * @version 1.0.3
 * @license MIT
 * @example
 * import Router from "./router/router.js" || use window.Router
 * const app = new Router('/')
 * app.use('/')
 * app.get('/', (req, res) => {
 *   res.return() // remove last hook
 *   res.render('index')
 * })
 * app.on('/', (req, res) => {
 *  res.return() // remove last hook
 * res.render('index')
 * })
 */;class Router{constructor(e){this.routes={},this.currentUrl="",this.store={},this.rootElement=null,this.hashChangeListener=null,this.listeners={},this.storedroutes=[],this.errorcheck=null,this.headers={},this.customerror=null,this.hooked=!1,e&&this.root(e,()=>{})}get(e,t){const n=[],s=[],o=e.split("/").map(e=>e.startsWith(":")?(n.push(e.substring(1)),"([^/]+)"):e.startsWith("*")?(n.push(e.substring(1)),"(.*)"):e.startsWith("?")?(s.push(e.substring(1)),"([^/]+)"):e).join("/"),r=new RegExp("^"+o+"(\\?(.*))?$");if(window.location.hash.substring(1).match(r)){this.storedroutes.push(window.location.hash.substring(1)),this.hooked=!0,this.routes[e]=!0;const s=window.location.hash.substring(1).match(r),o={};for(let e=0;e<n.length;e++)o[n[e]]=s[e+1];if(e.includes(":")&&window.location.hash.substring(1).split("?")[1])return"true"===window.config.log&&debug.log([`\n                  Cannot use query params with path params ${e} ${window.location.hash.substring(1).split("?")[1]}`],"assert"),!1;const i={},h=window.location.hash.substring(1).split("?")[1];if(h){const e=h.split("&");for(let t=0;t<e.length;t++){const n=e[t].split("=");i[n[0]]=n[1]}}const a={params:o,query:i,url:window.location.hash.substring(1),method:"GET"};return window.$URL_PARAMS=o,window.$URL_QUERY=i,methods.rootElement=this.rootElement,methods.hashChangeListener=this.hashChangeListener,t(a,methods),!0}return this.hooked=!1,!1}error(e){this.errorcheck=!0;window.onhashchange=(()=>{if(!this.storedroutes.includes(window.location.hash.substring(1))){const t=methods;null===this.customerror?document.getElementById(this.rootElement).innerHTML=`<code>Cannot GET ${window.location.hash.substring(1)}</code>`:e(t)}});const t=methods;this.storedroutes.includes(window.location.hash.substring(1))||(this.customerror?e(t):document.getElementById(this.rootElement).innerHTML=`<code>Cannot GET ${window.location.hash.substring(1)}</code>`)}root(e,t){const n=[],s=[],o=window.location.hash.substring(1);this.hooked||this.storedroutes.includes(o)||(this.storedroutes.push(o),window.location.hash=o);const r=e.split("/").map(e=>e.startsWith(":")?(n.push(e.substring(1)),"([^/]+)"):e.startsWith("*")?(n.push(e.substring(1)),"(.*)"):e.startsWith("?")?(s.push(e.substring(1)),"([^/]+)"):e).join("/"),i=new RegExp("^"+r+"(\\?(.*))?$");if(""===o)if(0===n.length)window.location.hash=e;else{const t=e.split("/").map(e=>e.startsWith(":")?"":e).join("/");window.location.hash=t}else{const t=o.match(i);if(t){const s={};n.forEach((e,n)=>{s[e]=t[n+1]});const o=e.split("/").map(e=>e.startsWith(":")?s[e.substring(1)]:e).join("/");window.location.hash=o}}if(this.routes[e]=!0,this.currentUrl=e,window.$CURRENT_URL=e,window.location.hash.substring(1).match(i)){const s=window.location.hash.substring(1).match(i),o={};for(let e=0;e<n.length;e++)o[n[e]]=s[e+1];if(e.includes(":")&&window.location.hash.substring(1).split("?")[1])return console.error(`\n                 [DoxDom: Cannot use query params with path params ${e} ${window.location.hash.substring(1).split("?")[1]}\n                `),!1;const r={},h=window.location.hash.substring(1).split("?")[1];if(h){const e=h.split("&");for(let t=0;t<e.length;t++){const n=e[t].split("=");r[n[0]]=n[1]}}const a={params:o,query:r,url:window.location.hash.substring(1),method:"ROOT_GET"};window.$URL_PARAMS=o,window.$URL_QUERY=r,methods.rootElement=this.rootElement,methods.hashChangeListener=this.hashChangeListener;const d=methods;return this.hashChangeListener||(this.hashChangeListener=(()=>{if(window.location.hash.substring(1).match(i)){const e=window.location.hash.substring(1).match(i),s={};for(let t=0;t<n.length;t++)s[n[t]]=e[t+1];const o={params:s,rootUrl:this.currentUrl,url:window.location.hash.substring(1)};window.$CURRENT_URL=window.location.hash.substring(1),t(o,methods)}}),window.addEventListener("hashchange",this.hashChangeListener)),t(a,d),!0}return!1}post(e,t){let n=!1;this.sendContent=null,t({set:(e,t)=>{let n=["Accept","Accept-Charset","Accept-Encoding","Accept-Language","Accept-Datetime","Access-Control-Request-Method","Access-Control-Request-Headers","Authorization","Cache-Control","Connection","Cookie","Content-Length","Content-MD5","Content-Type","Date"];if(!n.includes(e))throw new Error({message:"Invalid header name",name:e,accepted_headers:n});if("string"!=typeof t)throw new Error("Invalid header value");this.headers[e]=t},json:e=>{if("application/json"!=this.headers["Content-Type"])throw new Error("Content-Type header must be set to application/json");if(n)throw new Error("Cannot send headers after they where already sent please refrain from using double res functions and call res.return() to resend to client");try{const t=JSON.stringify(e);this.sendContent=t,n=!0}catch(e){throw new Error("Invalid JSON data")}},jsonp:e=>{if("application/json"!=this.headers["Content-Type"])throw new Error("Content-Type header must be set to application/json");if(n)throw new Error("Cannot send headers after they where already sent please refrain from using double res functions and call res.return() to resend to client");try{const t=JSON.stringify(e);this.sendContent=`callback(${t})`,n=!0}catch(e){throw new Error("Invalid JSON data")}},text:e=>{if("text/plain"==this.headers["Content-Type"]){if(n)throw new Error("Cannot send headers after they where already sent please refrain from using double res functions and call res.return() to resend to client");try{const t=e;this.sendContent=t,n=!0}catch(e){throw new Error("Invalid text data")}}},return:()=>{n&&(n=!1),this.hashChangeListener&&(window.removeEventListener("hashchange",this.hashChangeListener),this.hashChangeListener=null,console.log("removed last event listener"))}});const s={path:e,data:this.sendContent,headers:this.headers};window.postMessage(s,"*")}listen(e,t){if(this.listeners[e])throw new Error(`Listener already registered for route ${e}`);const n=n=>{const s=n.data.path,o=n.data.data,r=n.data.headers;s===e&&t({data:o,headers:r,method:"POST"})};"true"===window.config.log&&console.log(`[DoxDom: Listening for POST requests on route ${e}]`),window.addEventListener("message",n),this.listeners[e]=n}stopListening(e){const t=this.listeners[e];t&&(window.removeEventListener("message",t),delete this.listeners[e])}use(e){const t=[],n=[],s=e.split("/").map(e=>e.startsWith(":")?(t.push(e.substring(1)),"([^/]+)"):e.startsWith("*")?(t.push(e.substring(1)),"(.*)"):e.startsWith("?")?(n.push(e.substring(1)),"([^/]+)"):e).join("/");new RegExp("^"+s+"(\\?(.*))?$");e=s,this.routes[e]=!0,this.storedroutes.push(e)}bindRoot(e){this.rootElement=e}onload(e){"complete"!==document.readyState&&"interactive"!==document.readyState||e()}on(e,t){window.addEventListener("hashchange",()=>{const n=[],s=[],o=e.split("/").map(e=>e.startsWith(":")?(n.push(e.substring(1)),"([^/]+)"):e.startsWith("*")?(n.push(e.substring(1)),"(.*)"):e.startsWith("?")?(s.push(e.substring(1)),"([^/]+)"):e).join("/"),r=new RegExp("^"+o+"(\\?(.*))?$");if(this.routes[e]=!0,this.currentUrl=e,window.$CURRENT_URL=e,window.location.hash.substring(1).match(r)){this.storedroutes.push(window.location.hash.substring(1)),this.routes[e]=!0;const s=window.location.hash.substring(1).match(r),o={};for(let e=0;e<n.length;e++)o[n[e]]=s[e+1];if(e.includes(":")&&window.location.hash.substring(1).split("?")[1])return console.error("Cannot use query params with path params",e,window.location.hash.substring(1).split("?")[1]),!1;const i={},h=window.location.hash.substring(1).split("?")[1];if(h){const e=h.split("&");for(let t=0;t<e.length;t++){const n=e[t].split("=");i[n[0]]=n[1]}}const a={params:o,query:i,url:window.location.hash.substring(1),method:"POST"};window.$URL_QUERY=i,window.$URL_PARAMS=o,methods.rootElement=this.rootElement,methods.hashChangeListener=this.hashChangeListener,t(a,methods)}})}}export default Router;window.Router=Router;
